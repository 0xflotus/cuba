{"name":"Cuba","tagline":"Rum based microframework for web development.","body":"Viva Cuba!\r\n==========\r\n\r\nCuba is a Ruby microframework for web development.\r\n\r\nCommunity\r\n---------\r\n\r\nMeet us on IRC: [#cuba.rb](irc://chat.freenode.net/#cuba.rb) on [freenode.net](http://freenode.net/)\r\n\r\nDescription\r\n-----------\r\n\r\nCuba was originally inspired by [Rum][rum], a tiny but powerful mapper for [Rack][rack] applications.\r\n\r\nIt integrates many templates via [Tilt][tilt], and testing via\r\n[Cutest][cutest] and [Capybara][capybara].\r\n\r\n[rum]: http://github.com/chneukirchen/rum\r\n[rack]: http://github.com/chneukirchen/rack\r\n[tilt]: http://github.com/rtomayko/tilt\r\n[cutest]: http://github.com/djanowski/cutest\r\n[capybara]: http://github.com/jnicklas/capybara\r\n[rack-test]: https://github.com/brynary/rack-test\r\n\r\nUsage\r\n-----\r\n\r\nHere's a simple application:\r\n\r\n``` ruby\r\n# cat hello_world.rb\r\nrequire \"cuba\"\r\n\r\nCuba.use Rack::Session::Cookie,\r\n  secret: \"__a_very_long_string__\"\r\n\r\nCuba.define do\r\n  on get do\r\n    on \"hello\" do\r\n      res.write \"Hello world!\"\r\n    end\r\n\r\n    on root do\r\n      res.redirect \"/hello\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAnd the test file:\r\n\r\n``` ruby\r\n# cat hello_world_test.rb\r\nrequire \"cuba/test\"\r\nrequire \"./hello_world\"\r\n\r\nscope do\r\n  test \"Homepage\" do\r\n    get \"/\"\r\n\r\n    follow_redirect!\r\n\r\n    assert_equal \"Hello world!\", last_response.body\r\n  end\r\nend\r\n```\r\n\r\nTo run it, you can create a `config.ru` file:\r\n\r\n``` ruby\r\n# cat config.ru\r\nrequire \"./hello_world\"\r\n\r\nrun Cuba\r\n```\r\n\r\nYou can now run `rackup` and enjoy what you have just created.\r\n\r\nMatchers\r\n--------\r\n\r\nHere's an example showcasing how different matchers work:\r\n\r\n``` ruby\r\nrequire \"cuba\"\r\n\r\nCuba.use Rack::Session::Cookie,\r\n  secret: \"__a_very_long_string__\"\r\n\r\nCuba.define do\r\n\r\n  # only GET requests\r\n  on get do\r\n\r\n    # /\r\n    on root do\r\n      res.write \"Home\"\r\n    end\r\n\r\n    # /about\r\n    on \"about\" do\r\n      res.write \"About\"\r\n    end\r\n\r\n    # /styles/basic.css\r\n    on \"styles\", extension(\"css\") do |file|\r\n      res.write \"Filename: #{file}\" #=> \"Filename: basic\"\r\n    end\r\n\r\n    # /post/2011/02/16/hello\r\n    on \"post/:y/:m/:d/:slug\" do |y, m, d, slug|\r\n      res.write \"#{y}-#{m}-#{d} #{slug}\" #=> \"2011-02-16 hello\"\r\n    end\r\n\r\n    # /username/foobar\r\n    on \"username/:username\" do |username|\r\n      user = User.find_by_username(username) # username == \"foobar\"\r\n\r\n      # /username/foobar/posts\r\n      on \"posts\" do\r\n\r\n        # You can access `user` here, because the `on` blocks\r\n        # are closures.\r\n        res.write \"Total Posts: #{user.posts.size}\" #=> \"Total Posts: 6\"\r\n      end\r\n\r\n      # /username/foobar/following\r\n      on \"following\" do\r\n        res.write user.following.size #=> \"1301\"\r\n      end\r\n    end\r\n\r\n    # /search?q=barbaz\r\n    on \"search\", param(\"q\") do |query|\r\n      res.write \"Searched for #{query}\" #=> \"Searched for barbaz\"\r\n    end\r\n  end\r\n\r\n  # only POST requests\r\n  on post do\r\n    on \"login\"\r\n\r\n      # POST /login, user: foo, pass: baz\r\n      on param(\"user\"), param(\"pass\") do |user, pass|\r\n        res.write \"#{user}:#{pass}\" #=> \"foo:baz\"\r\n      end\r\n\r\n      # If the params `user` and `pass` are not provided, this block will\r\n      # get executed.\r\n      on true do\r\n        res.write \"You need to provide user and pass!\"\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nSecurity\r\n--------\r\n\r\nThe favorite security layer for Cuba is\r\n[Rack::Protection](https://github.com/rkh/rack-protection). It is not\r\nincluded by default because there are legitimate uses for plain Cuba\r\n(for instance, when designing an API).\r\n\r\nIf you are building a web application, by all means make sure to\r\ninclude a security layer. As it is the convention for unsafe\r\noperations, only POST, PUT and DELETE requests are monitored.\r\n\r\n``` ruby\r\nrequire \"cuba\"\r\nrequire \"rack/protection\"\r\n\r\nCuba.use Rack::Session::Cookie,\r\n  secret: \"__a_very_long_string__\"\r\nCuba.use Rack::Protection\r\nCuba.use Rack::Protection::RemoteReferrer\r\n\r\nCuba.define do\r\n\r\n  # Now your app is protected against a wide range of attacks.\r\n  ...\r\nend\r\n```\r\n\r\nHTTP Verbs\r\n----------\r\n\r\nThere are four matchers defined for HTTP Verbs: `get`, `post`, `put` and\r\n`delete`. But the world doesn't end there, does it? As you have the whole\r\nrequest available via the `req` object, you can query it with helper methods\r\nlike `req.options?` or `req.head?`, or you can even go to a lower level\r\nand inspect the environment via the `env` object, and check for example if\r\n`env[\"REQUEST_METHOD\"]` equals the obscure verb `PATCH`.\r\n\r\nWhat follows is an example of different ways of saying the same thing:\r\n\r\n``` ruby\r\non env[\"REQUEST_METHOD\"] == \"GET\", \"api\" do ... end\r\n\r\non req.get?, \"api\" do ... end\r\n\r\non get, \"api\" do ... end\r\n```\r\n\r\nActually, `get` is syntax sugar for `req.get?`, which in turn is syntax sugar\r\nfor `env[\"REQUEST_METHOD\"] == \"GET\"`.\r\n\r\nCaptures\r\n--------\r\n\r\nYou may have noticed that some matchers yield a value to the block. The rules\r\nfor determining if a matcher will yield a value are simple:\r\n\r\n1. Regex captures: `\"posts/(\\\\d+)-(.*)\"` will yield two values, corresponding to each capture.\r\n2. Placeholders: `\"users/:id\"` will yield the value in the position of :id.\r\n3. Symbols: `:foobar` will yield if a segment is available.\r\n4. File extensions: `extension(\"css\")` will yield the basename of the matched file.\r\n5. Parameters: `param(\"user\")` will yield the value of the parameter user, if present.\r\n\r\nThe first case is important because it shows the underlying effect of regex\r\ncaptures.\r\n\r\nIn the second case, the substring `:id` gets replaced by `([^\\\\/]+)` and the\r\nstring becomes `\"users/([^\\\\/]+)\"` before performing the match, thus it reverts\r\nto the first form we saw.\r\n\r\nIn the third case, the symbol ––no matter what it says––gets replaced\r\nby `\"([^\\\\/]+)\"`, and again we are in presence of case 1.\r\n\r\nThe fourth case, again, reverts to the basic matcher: it generates the string\r\n`\"([^\\\\/]+?)\\.#{ext}\\\\z\"` before performing the match.\r\n\r\nThe fifth case is different: it checks if the the parameter supplied is present\r\nin the request (via POST or QUERY_STRING) and it pushes the value as a capture.\r\n\r\nComposition\r\n-----------\r\n\r\nYou can mount a Cuba app, along with middlewares, inside another Cuba app:\r\n\r\n``` ruby\r\nclass API < Cuba; end\r\n\r\nAPI.use SomeMiddleware\r\n\r\nAPI.define do\r\n  on param(\"url\") do |url|\r\n    ...\r\n  end\r\nend\r\n\r\nCuba.define do\r\n  on \"api\" do\r\n    run API\r\n  end\r\nend\r\n```\r\n\r\nTesting\r\n-------\r\n\r\nGiven that Cuba is essentially Rack, it is very easy to test with\r\n`Rack::Test`, `Webrat` or `Capybara`. Cuba's own tests are written\r\nwith a combination of [Cutest][cutest] and [Rack::Test][rack-test],\r\nand if you want to use the same for your tests it is as easy as\r\nrequiring `cuba/test`:\r\n\r\n``` ruby\r\nrequire \"cuba/test\"\r\nrequire \"your/app\"\r\n\r\nscope do\r\n  test \"Homepage\" do\r\n    get \"/\"\r\n\r\n    assert_equal \"Hello world!\", last_response.body\r\n  end\r\nend\r\n```\r\n\r\nIf you prefer to use [Capybara][capybara], instead of requiring\r\n`cuba/test` you can require `cuba/capybara`:\r\n\r\n``` ruby\r\nrequire \"cuba/capybara\"\r\nrequire \"your/app\"\r\n\r\nscope do\r\n  test \"Homepage\" do\r\n    visit \"/\"\r\n\r\n    assert has_content?(\"Hello world!\")\r\n  end\r\nend\r\n```\r\n\r\nTo read more about testing, check the documentation for\r\n[Cutest][cutest], [Rack::Test][rack-test] and [Capybara][capybara].\r\n\r\nSettings\r\n--------\r\n\r\nEach Cuba app can store settings in the `Cuba.settings` hash. The settings are\r\ninherited if you happen to subclass `Cuba`\r\n\r\n``` ruby\r\nCuba.settings[:layout] = \"guest\"\r\n\r\nclass Users < Cuba; end\r\nclass Admin < Cuba; end\r\n\r\nAdmin.settings[:layout] = \"admin\"\r\n\r\nassert_equal \"guest\", Users.settings[:layout]\r\nassert_equal \"admin\", Admin.settings[:layout]\r\n```\r\n\r\nFeel free to store whatever you find convenient.\r\n\r\nRendering\r\n---------\r\n\r\nCuba ships with a plugin that provides helpers for rendering templates. It uses\r\n[Tilt][tilt], a gem that interfaces with many template engines.\r\n\r\n``` ruby\r\nrequire \"cuba/render\"\r\n\r\nCuba.plugin Cuba::Render\r\n\r\nCuba.define do\r\n  on default do\r\n\r\n    # Within the partial, you will have access to the local variable `content`,\r\n    # that will hold the value \"hello, world\".\r\n    res.write render(\"home.haml\", content: \"hello, world\")\r\n  end\r\nend\r\n```\r\n\r\nNote that in order to use this plugin you need to have [Tilt][tilt] installed, along\r\nwith the templating engines you want to use.\r\n\r\nPlugins\r\n-------\r\n\r\nCuba provides a way to extend its functionality with plugins.\r\n\r\n### How to create plugins\r\n\r\nAuthoring your own plugins is pretty straightforward.\r\n\r\n``` ruby\r\nmodule MyOwnHelper\r\n  def markdown(str)\r\n    BlueCloth.new(str).to_html\r\n  end\r\nend\r\n\r\nCuba.plugin MyOwnHelper\r\n```\r\n\r\nThat's the simplest kind of plugin you'll write. In fact, that's exactly how\r\nthe `markdown` helper is written in `Cuba::TextHelpers`.\r\n\r\nA more complicated plugin can make use of `Cuba.settings` to provide default\r\nvalues. In the following example, note that if the module has a `setup` method it will\r\nbe called as soon as it is included:\r\n\r\n``` ruby\r\nmodule Render\r\n  def self.setup(app)\r\n    app.settings[:template_engine] = \"erb\"\r\n  end\r\n\r\n  def partial(template, locals = {})\r\n    render(\"#{template}.#{settings[:template_engine]}\", locals)\r\n  end\r\nend\r\n\r\nCuba.plugin Render\r\n```\r\n\r\nThis sample plugin actually resembles how `Cuba::Render` works.\r\n\r\nFinally, if a module called `ClassMethods` is present, `Cuba` will be extended\r\nwith it.\r\n\r\n``` ruby\r\nmodule GetSetter\r\n  module ClassMethods\r\n    def set(key, value)\r\n      settings[key] = value\r\n    end\r\n\r\n    def get(key)\r\n      settings[key]\r\n    end\r\n  end\r\nend\r\n\r\nCuba.plugin GetSetter\r\n\r\nCuba.set(:foo, \"bar\")\r\n\r\nassert_equal \"bar\", Cuba.get(:foo)\r\nassert_equal \"bar\", Cuba.settings[:foo]\r\n```\r\n\r\nInstallation\r\n------------\r\n\r\n``` ruby\r\n$ gem install cuba\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}