{"name":"Cuba","tagline":"Rum based microframework for web development.","body":"Viva Cuba!\r\n==========\r\n\r\nCuba is a Ruby microframework for web development.\r\n\r\nCommunity\r\n---------\r\n\r\nMeet us on IRC: [#cuba.rb][irc] on [freenode.net][freenode].\r\n\r\n[irc]: irc://chat.freenode.net/#cuba.rb\r\n[freenode]: http://freenode.net/\r\n\r\nDescription\r\n-----------\r\n\r\nCuba is a microframework for web development originally inspired\r\nby [Rum][rum], a tiny but powerful mapper for [Rack][rack]\r\napplications.\r\n\r\nIt integrates many templates via [Tilt][tilt], and testing via\r\n[Cutest][cutest] and [Capybara][capybara].\r\n\r\n[rum]: http://github.com/chneukirchen/rum\r\n[rack]: http://github.com/chneukirchen/rack\r\n[tilt]: http://github.com/rtomayko/tilt\r\n[cutest]: http://github.com/djanowski/cutest\r\n[capybara]: http://github.com/jnicklas/capybara\r\n[rack-test]: https://github.com/brynary/rack-test\r\n\r\nGuide\r\n-----\r\n\r\nThere's a book called [The Guide to Cuba][guide] that explains how\r\nto build web applications by following a minimalistic approach. It\r\nis recommended reading for anyone trying to learn the basics of\r\nCuba and other related tools.\r\n\r\n[guide]: http://theguidetocuba.io\r\n\r\nInstallation\r\n------------\r\n\r\n``` console\r\n$ gem install cuba\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nHere's a simple application:\r\n\r\n``` ruby\r\n# cat hello_world.rb\r\nrequire \"cuba\"\r\nrequire \"cuba/safe\"\r\n\r\nCuba.use Rack::Session::Cookie, :secret => \"__a_very_long_string__\"\r\n\r\nCuba.plugin Cuba::Safe\r\n\r\nCuba.define do\r\n  on get do\r\n    on \"hello\" do\r\n      res.write \"Hello world!\"\r\n    end\r\n\r\n    on root do\r\n      res.redirect \"/hello\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nAnd the test file:\r\n\r\n``` ruby\r\n# cat hello_world_test.rb\r\nrequire \"cuba/test\"\r\nrequire \"./hello_world\"\r\n\r\nscope do\r\n  test \"Homepage\" do\r\n    get \"/\"\r\n\r\n    follow_redirect!\r\n\r\n    assert_equal \"Hello world!\", last_response.body\r\n  end\r\nend\r\n```\r\n\r\nTo run it, you can create a `config.ru` file:\r\n\r\n``` ruby\r\n# cat config.ru\r\nrequire \"./hello_world\"\r\n\r\nrun Cuba\r\n```\r\n\r\nYou can now run `rackup` and enjoy what you have just created.\r\n\r\nMatchers\r\n--------\r\n\r\nHere's an example showcasing how different matchers work:\r\n\r\n``` ruby\r\nrequire \"cuba\"\r\nrequire \"cuba/safe\"\r\n\r\nCuba.use Rack::Session::Cookie, :secret => \"__a_very_long_string__\"\r\n\r\nCuba.plugin Cuba::Safe\r\n\r\nCuba.define do\r\n\r\n  # only GET requests\r\n  on get do\r\n\r\n    # /\r\n    on root do\r\n      res.write \"Home\"\r\n    end\r\n\r\n    # /about\r\n    on \"about\" do\r\n      res.write \"About\"\r\n    end\r\n\r\n    # /styles/basic.css\r\n    on \"styles\", extension(\"css\") do |file|\r\n      res.write \"Filename: #{file}\" #=> \"Filename: basic\"\r\n    end\r\n\r\n    # /post/2011/02/16/hello\r\n    on \"post/:y/:m/:d/:slug\" do |y, m, d, slug|\r\n      res.write \"#{y}-#{m}-#{d} #{slug}\" #=> \"2011-02-16 hello\"\r\n    end\r\n\r\n    # /username/foobar\r\n    on \"username/:username\" do |username|\r\n      user = User.find_by_username(username) # username == \"foobar\"\r\n\r\n      # /username/foobar/posts\r\n      on \"posts\" do\r\n\r\n        # You can access `user` here, because the `on` blocks\r\n        # are closures.\r\n        res.write \"Total Posts: #{user.posts.size}\" #=> \"Total Posts: 6\"\r\n      end\r\n\r\n      # /username/foobar/following\r\n      on \"following\" do\r\n        res.write user.following.size #=> \"1301\"\r\n      end\r\n    end\r\n\r\n    # /search?q=barbaz\r\n    on \"search\", param(\"q\") do |query|\r\n      res.write \"Searched for #{query}\" #=> \"Searched for barbaz\"\r\n    end\r\n  end\r\n\r\n  # only POST requests\r\n  on post do\r\n    on \"login\" do\r\n\r\n      # POST /login, user: foo, pass: baz\r\n      on param(\"user\"), param(\"pass\") do |user, pass|\r\n        res.write \"#{user}:#{pass}\" #=> \"foo:baz\"\r\n      end\r\n\r\n      # If the params `user` and `pass` are not provided, this\r\n      # block will get executed.\r\n      on true do\r\n        res.write \"You need to provide user and pass!\"\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nStatus codes\r\n------------\r\n\r\nIf you don't assign a status code and you don't write to the `res`\r\nobject, the status will be set as `404`.\r\n\r\nFor example:\r\n\r\n``` ruby\r\nCuba.define do\r\n  on get do\r\n    on \"hello\" do\r\n      res.write \"hello world\"\r\n    end\r\n  end\r\nend\r\n\r\n# Requests:\r\n#\r\n# GET /            # 404\r\n# GET /hello       # 200\r\n# GET /hello/world # 200\r\n```\r\n\r\nAs you can see, as soon as something was written to the response,\r\nthe status code was changed to 200.\r\n\r\nIf you want to match just \"hello\", but not \"hello/world\", you can do\r\nas follows:\r\n\r\n``` ruby\r\nCuba.define do\r\n  on get do\r\n    on \"hello\" do\r\n      on root do\r\n        res.write \"hello world\"\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\n# Requests:\r\n#\r\n# GET /            # 404\r\n# GET /hello       # 200\r\n# GET /hello/world # 404\r\n```\r\n\r\nYou can also use a regular expression to match the end of line:\r\n\r\n``` ruby\r\nCuba.define do\r\n  on get do\r\n    on /hello\\/?\\z/ do\r\n      res.write \"hello world\"\r\n    end\r\n  end\r\nend\r\n\r\n# Requests:\r\n#\r\n# GET /            # 404\r\n# GET /hello       # 200\r\n# GET /hello/world # 404\r\n```\r\n\r\nThis last example is not a common usage pattern. It's here only to\r\nillustrate how Cuba can be adapted for different use cases.\r\n\r\nIf you need this behavior, you can create a helper:\r\n\r\n``` ruby\r\nmodule TerminalMatcher\r\n  def terminal(path)\r\n    /#{path}\\/?\\z/\r\n  end\r\nend\r\n\r\nCuba.plugin TerminalMatcher\r\n\r\nCuba.define do\r\n  on get do\r\n    on terminal(\"hello\") do\r\n      res.write \"hello world\"\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nSecurity\r\n--------\r\n\r\nThe most important security consideration is to use `https` for all\r\nrequests. If that's not the case, any attempt to secure the application\r\ncould be in vain. The rest of this section assumes `https` is\r\nenforced.\r\n\r\nWhen building a web application, you need to include a security\r\nlayer. Cuba ships with the `Cuba::Safe` plugin, which applies several\r\nsecurity related headers to prevent attacks like clickjacking and\r\ncross-site scripting, among others. It is not included by default\r\nbecause there are legitimate uses for plain Cuba (for instance,\r\nwhen designing an API).\r\n\r\nHere's how to include it:\r\n\r\n```ruby\r\nrequire \"cuba/safe\"\r\n\r\nCuba.plugin Cuba::Safe\r\n```\r\n\r\nYou should also always set a session secret to some undisclosed\r\nvalue. Keep in mind that the content in the session cookie is\r\n*not* encrypted.\r\n\r\n``` ruby\r\nCuba.use(Rack::Session::Cookie, :secret => \"__a_very_long_string__\")\r\n```\r\n\r\nIn the end, your application should look like this:\r\n\r\n```ruby\r\nrequire \"cuba\"\r\nrequire \"cuba/safe\"\r\n\r\nCuba.use Rack::Session::Cookie, :secret => \"__a_very_long_string__\"\r\n\r\nCuba.plugin Cuba::Safe\r\n\r\nCuba.define do\r\n  on csrf.unsafe? do\r\n    csrf.reset!\r\n\r\n    res.status = 403\r\n    res.write(\"Not authorized\")\r\n\r\n    halt(res.finish)\r\n  end\r\n\r\n  # Now your app is protected against a wide range of attacks.\r\n  ...\r\nend\r\n```\r\n\r\nThe `Cuba::Safe` plugin is composed of two modules:\r\n\r\n* `Cuba::Safe::SecureHeaders`\r\n* `Cuba::Safe::CSRF`\r\n\r\nYou can include them individually, but while the modularity is good\r\nfor development, it's very common to use them in tandem. As that's\r\nthe normal use case, including `Cuba::Safe` is the preferred way.\r\n\r\nCross-Site Request Forgery\r\n--------------------------\r\n\r\nThe `Cuba::Safe::CSRF` plugin provides a `csrf` object with the\r\nfollowing methods:\r\n\r\n* `token`: the current security token.\r\n* `reset!`: forces the token to be recreated.\r\n* `safe?`: returns `true` if the request is safe.\r\n* `unsafe?`: returns `true` if the request is unsafe.\r\n* `form_tag`: returns a string with the `csrf_token` hidden input tag.\r\n* `meta_tag`: returns a string with the `csrf_token` meta tag.\r\n\r\nHere's an example of how to use it:\r\n\r\n```ruby\r\nrequire \"cuba\"\r\nrequire \"cuba/safe\"\r\n\r\nCuba.use Rack::Session::Cookie, :secret => \"__a_very_long_string__\"\r\n\r\nCuba.plugin Cuba::Safe\r\n\r\nCuba.define do\r\n  on csrf.unsafe? do\r\n    csrf.reset!\r\n\r\n    res.status = 403\r\n    res.write(\"Not authorized\")\r\n\r\n    halt(res.finish)\r\n  end\r\n\r\n  # Here comes the rest of your application\r\n  # ...\r\nend\r\n```\r\n\r\nYou have to include `csrf.form_tag` in your forms and `csrf.meta_tag`\r\namong your meta tags. Here's an example that assumes you are using\r\n`Cuba::Mote` from `cuba-contrib`:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    {{ app.csrf.meta_tag }}\r\n    ...\r\n  </head>\r\n  ...\r\n  <body>\r\n    <form action=\"/foo\" method=\"POST\">\r\n      {{ app.csrf.form_tag }}\r\n      ...\r\n    </form>\r\n  ...\r\n  </body>\r\n</html>\r\n```\r\n\r\nHTTP Verbs\r\n----------\r\n\r\nThere are four matchers defined for HTTP Verbs: `get`, `post`, `put` and\r\n`delete`. But the world doesn't end there, does it? As you have the whole\r\nrequest available via the `req` object, you can query it with helper methods\r\nlike `req.options?` or `req.head?`, or you can even go to a lower level\r\nand inspect the environment via the `env` object, and check for example if\r\n`env[\"REQUEST_METHOD\"]` equals the obscure verb `PATCH`.\r\n\r\nWhat follows is an example of different ways of saying the same thing:\r\n\r\n``` ruby\r\non env[\"REQUEST_METHOD\"] == \"GET\", \"api\" do ... end\r\n\r\non req.get?, \"api\" do ... end\r\n\r\non get, \"api\" do ... end\r\n```\r\n\r\nActually, `get` is syntax sugar for `req.get?`, which in turn is syntax sugar\r\nfor `env[\"REQUEST_METHOD\"] == \"GET\"`.\r\n\r\nRequest and Response\r\n--------------------\r\n\r\nYou may have noticed we use `req` and `res` a lot. Those variables are\r\ninstances of [Rack::Request][request] and `Cuba::Response` respectively, and\r\n`Cuba::Response` is just an optimized version of\r\n[Rack::Response][response].\r\n\r\n[request]: http://rack.rubyforge.org/doc/classes/Rack/Request.html\r\n[response]: http://rack.rubyforge.org/doc/classes/Rack/Response.html\r\n\r\nThose objects are helpers for accessing the request and for building\r\nthe response. Most of the time, you will just use `res.write`.\r\n\r\nIf you want to use custom `Request` or `Response` objects, you can\r\nset the new values as follows:\r\n\r\n``` ruby\r\nCuba.settings[:req] = MyRequest\r\nCuba.settings[:res] = MyResponse\r\n```\r\n\r\nMake sure to provide classes compatible with those from Rack.\r\n\r\nCaptures\r\n--------\r\n\r\nYou may have noticed that some matchers yield a value to the block. The rules\r\nfor determining if a matcher will yield a value are simple:\r\n\r\n1. Regex captures: `\"posts/(\\\\d+)-(.*)\"` will yield two values, corresponding to each capture.\r\n2. Placeholders: `\"users/:id\"` will yield the value in the position of :id.\r\n3. Symbols: `:foobar` will yield if a segment is available.\r\n4. File extensions: `extension(\"css\")` will yield the basename of the matched file.\r\n5. Parameters: `param(\"user\")` will yield the value of the parameter user, if present.\r\n\r\nThe first case is important because it shows the underlying effect of regex\r\ncaptures.\r\n\r\nIn the second case, the substring `:id` gets replaced by `([^\\\\/]+)` and the\r\nstring becomes `\"users/([^\\\\/]+)\"` before performing the match, thus it reverts\r\nto the first form we saw.\r\n\r\nIn the third case, the symbol â€“â€“no matter what it saysâ€“â€“gets replaced\r\nby `\"([^\\\\/]+)\"`, and again we are in presence of case 1.\r\n\r\nThe fourth case, again, reverts to the basic matcher: it generates the string\r\n`\"([^\\\\/]+?)\\.#{ext}\\\\z\"` before performing the match.\r\n\r\nThe fifth case is different: it checks if the the parameter supplied is present\r\nin the request (via POST or QUERY_STRING) and it pushes the value as a capture.\r\n\r\nComposition\r\n-----------\r\n\r\nYou can mount a Cuba app, along with middlewares, inside another Cuba app:\r\n\r\n``` ruby\r\nclass API < Cuba; end\r\n\r\nAPI.use SomeMiddleware\r\n\r\nAPI.define do\r\n  on param(\"url\") do |url|\r\n    ...\r\n  end\r\nend\r\n\r\nCuba.define do\r\n  on \"api\" do\r\n    run API\r\n  end\r\nend\r\n```\r\n\r\nIf you need to pass information to one sub-app, you can use the\r\n`with` method and access it with `vars`:\r\n\r\n```ruby\r\nclass Platforms < Cuba\r\n  define do\r\n    platform = vars[:platform]\r\n\r\n    on default do\r\n      res.write(platform) # => \"heroku\" or \"salesforce\"\r\n    end\r\n  end\r\nend\r\n\r\nCuba.define do\r\n  on \"(heroku|salesforce)\" do |platform|\r\n    with(platform: platform) do\r\n      run(Platforms)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nTesting\r\n-------\r\n\r\nGiven that Cuba is essentially Rack, it is very easy to test with\r\n`Rack::Test`, `Webrat` or `Capybara`. Cuba's own tests are written\r\nwith a combination of [Cutest][cutest] and [Rack::Test][rack-test],\r\nand if you want to use the same for your tests it is as easy as\r\nrequiring `cuba/test`:\r\n\r\n``` ruby\r\nrequire \"cuba/test\"\r\nrequire \"your/app\"\r\n\r\nscope do\r\n  test \"Homepage\" do\r\n    get \"/\"\r\n\r\n    assert_equal \"Hello world!\", last_response.body\r\n  end\r\nend\r\n```\r\n\r\nIf you prefer to use [Capybara][capybara], instead of requiring\r\n`cuba/test` you can require `cuba/capybara`:\r\n\r\n``` ruby\r\nrequire \"cuba/capybara\"\r\nrequire \"your/app\"\r\n\r\nscope do\r\n  test \"Homepage\" do\r\n    visit \"/\"\r\n\r\n    assert has_content?(\"Hello world!\")\r\n  end\r\nend\r\n```\r\n\r\nTo read more about testing, check the documentation for\r\n[Cutest][cutest], [Rack::Test][rack-test] and [Capybara][capybara].\r\n\r\nSettings\r\n--------\r\n\r\nEach Cuba app can store settings in the `Cuba.settings` hash. The settings are\r\ninherited if you happen to subclass `Cuba`\r\n\r\n``` ruby\r\nCuba.settings[:layout] = \"guest\"\r\n\r\nclass Users < Cuba; end\r\nclass Admin < Cuba; end\r\n\r\nAdmin.settings[:layout] = \"admin\"\r\n\r\nassert_equal \"guest\", Users.settings[:layout]\r\nassert_equal \"admin\", Admin.settings[:layout]\r\n```\r\n\r\nFeel free to store whatever you find convenient.\r\n\r\nRendering\r\n---------\r\n\r\nCuba includes a plugin called `Cuba::Render` that provides a couple of helper\r\nmethods for rendering templates. This plugin uses [Tilt][tilt], which serves as\r\nan interface to a bunch of different Ruby template engines (ERB, Haml, Sass,\r\nCoffeeScript, etc.), so you can use the template engine of your choice.\r\n\r\nTo set up `Cuba::Render`, do:\r\n\r\n```ruby\r\nrequire \"cuba\"\r\nrequire \"cuba/render\"\r\nrequire \"erb\"\r\n\r\nCuba.plugin Cuba::Render\r\n```\r\n\r\nThis example uses ERB, a template engine that comes with Ruby. If you want to\r\nuse another template engine, one [supported by Tilt][templates], you need to\r\ninstall the required gem and change the `template_engine` setting as shown\r\nbelow.\r\n\r\n```ruby\r\nCuba.settings[:render][:template_engine] = \"haml\"\r\n```\r\n\r\nThe plugin provides three helper methods for rendering templates: `partial`,\r\n`view` and `render`.\r\n\r\n```ruby\r\nCuba.define do\r\n  on \"about\" do\r\n    # `partial` renders a template called `about.erb` without a layout.\r\n    res.write partial(\"about\")\r\n  end\r\n\r\n  on \"home\" do\r\n    # Opposed to `partial`, `view` renders the same template\r\n    # within a layout called `layout.erb`.\r\n    res.write view(\"about\")\r\n  end\r\n\r\n  on \"contact\" do\r\n    # `render` is a shortcut to `res.write view(...)`\r\n    render(\"contact\")\r\n  end\r\nend\r\n```\r\n\r\nBy default, `Cuba::Render` assumes that all templates are placed in a folder\r\nnamed `views` and that they use the proper extension for the chosen template\r\nengine. Also for the `view` and `render` methods, it assumes that the layout\r\ntemplate is called `layout`.\r\n\r\nThe defaults can be changed through the `Cuba.settings` method:\r\n\r\n```ruby\r\nCuba.settings[:render][:template_engine] = \"haml\"\r\nCuba.settings[:render][:views] = \"./views/admin/\"\r\nCuba.settings[:render][:layout] = \"admin\"\r\n```\r\n\r\nNOTE: Cuba doesn't ship with Tilt. You need to install it (`gem install tilt`).\r\n\r\n[templates]: https://github.com/rtomayko/tilt/blob/master/docs/TEMPLATES.md\r\n\r\nPlugins\r\n-------\r\n\r\nCuba provides a way to extend its functionality with plugins.\r\n\r\n### How to create plugins\r\n\r\nAuthoring your own plugins is pretty straightforward.\r\n\r\n``` ruby\r\nmodule MyOwnHelper\r\n  def markdown(str)\r\n    BlueCloth.new(str).to_html\r\n  end\r\nend\r\n\r\nCuba.plugin MyOwnHelper\r\n```\r\n\r\nThat's the simplest kind of plugin you'll write. In fact, that's exactly how\r\nthe `markdown` helper is written in `Cuba::TextHelpers`.\r\n\r\nA more complicated plugin can make use of `Cuba.settings` to provide default\r\nvalues. In the following example, note that if the module has a `setup` method, it will\r\nbe called as soon as it is included:\r\n\r\n``` ruby\r\nmodule Render\r\n  def self.setup(app)\r\n    app.settings[:template_engine] = \"erb\"\r\n  end\r\n\r\n  def partial(template, locals = {})\r\n    render(\"#{template}.#{settings[:template_engine]}\", locals)\r\n  end\r\nend\r\n\r\nCuba.plugin Render\r\n```\r\n\r\nThis sample plugin actually resembles how `Cuba::Render` works.\r\n\r\nFinally, if a module called `ClassMethods` is present, `Cuba` will be extended\r\nwith it.\r\n\r\n``` ruby\r\nmodule GetSetter\r\n  module ClassMethods\r\n    def set(key, value)\r\n      settings[key] = value\r\n    end\r\n\r\n    def get(key)\r\n      settings[key]\r\n    end\r\n  end\r\nend\r\n\r\nCuba.plugin GetSetter\r\n\r\nCuba.set(:foo, \"bar\")\r\n\r\nassert_equal \"bar\", Cuba.get(:foo)\r\nassert_equal \"bar\", Cuba.settings[:foo]\r\n```\r\n\r\nContributing\r\n------------\r\n\r\nA good first step is to meet us on IRC and discuss ideas. If that's\r\nnot possible, you can create an issue explaning the proposed change\r\nand a use case. We pay a lot of attention to use cases, because our\r\ngoal is to keep the code base simple. In many cases, the result of\r\na conversation will be the creation of another tool, instead of the\r\nmodification of Cuba itself.\r\n\r\nIf you want to test Cuba, you may want to use a gemset to isolate\r\nthe requirements. We recommend the use of tools like [dep][dep] and\r\n[gs][gs], but you can use similar tools like [gst][gst] or [bs][bs].\r\n\r\nThe required gems for testing and development are listed in the\r\n`.gems` file. If you are using [dep][dep], you can create a gemset\r\nand run `dep install`.\r\n\r\n[dep]: http://cyx.github.io/dep/\r\n[gs]: http://soveran.github.io/gs/\r\n[gst]: https://github.com/tonchis/gst\r\n[bs]: https://github.com/educabilia/bs\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}